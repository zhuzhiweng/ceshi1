#include "GB17691A.h"
//#include "bsp.h"
#include "cmsis_os.h"
#include "spi_flash.h"
#include "power_ctl.h"

#include "stm32f10x_bkp.h"

//#include "usb_data_process.h"

//static const uint8_t device_type_manage[4]={DEVICE_TYPE0,DEVICE_TYPE1,DEVICE_TYPE2,DEVICE_TYPE3};
//static const uint32_t ver_manage[64]={ VER0,VER1,VER2,VER3,VER4,VER5,VER6,VER7,VER8,VER9,VER10,VER11,VER12,VER13,VER14,VER15,
//																			 VER16,VER17,VER18,VER19,VER20,VER21,VER22,VER23, VER24,VER25,VER26,VER27,VER28,VER29,VER30,VER31,
//	                                     VER32,VER33,VER34,VER35,VER36,VER37,VER38,VER39, VER40,VER41,VER42,VER43,VER44,VER45,VER46,VER47,
//	                                     VER48,VER49,VER50,VER51,VER52,VER53,VER54,VER55, VER56,VER57,VER58,VER59,VER60,VER61,VER62,VER63};
//uint8_t vin_info[17] = {0x4C, 0x50, 0x48, 0x46, 0x41, 0x33, 0x42, 0x44, 0x30, 0x48, 0x59, 0x31, 0x37, 0x30, 0x32, 0x33, 0x35};    //vin信息
//uint8_t vin_info[17] = {0x4C, 0x44, 0x50, 0x46, 0x41, 0x41, 0x41, 0x42, 0x36, 0x48, 0x46, 0x31, 0x36, 0x31, 0x32, 0x35, 0x37};
//uint8_t vin_info[17] = {0x4C, 0x44, 0x4C, 0x41, 0x34, 0x32, 0x41, 0x44, 0x34, 0x4A, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31};
extern uint8_t vin_info[17];
//static uint8_t read_vin_state = 0;            //读VIN状态  0:不读VIN状态  1:读VIN状态
static uint8_t login_state = 0;               //登入状态   0:不登入状态   1:登入状态
uint8_t timing_state = 0;              //校时状态   0:非校时状态   1:校时状态
//static uint8_t alarm_state = 0;              //报警状态
static uint16_t lognum = 0;                   //登入次数    
static uint8_t send_data_cnt = 0;             //发数计数
static uint8_t GB17691_CMD_data[256];        //命令缓冲256  
static uint16_t gb17691_rd_pos = 0;           //读位置
static uint16_t cmd_data_len;                 //命令数据长度
static uint8_t check_cmd_info_flag = 0;       //检查命令信息标志
static uint8_t CMD_check_dealy;               //命令检查延时

//static uint32_t	pre_resend_timestamp;
//static uint8_t pre_resend_flag = 0;
static uint8_t GB17691_send_enable = 0;       //GB17691发送使能 0:不使能 1 :使能
	
//static uint32_t resend_record_addr = RESEND_RECORD_START_ADDR; //保存补发地址
//static uint32_t resend_wrtie_size = 0;                          //补发写大小初始为0

static uint32_t realtime_upload_flag_addr[HEART_INTERVAL];   //实时上报标记存储缓冲
static uint8_t realtime_load_cnt = 0;                        //实时上报计数
static uint32_t resend_msg_flag_addr[RESND_MSG_MAX_CNT];     //补发标记存储缓冲
static uint8_t resend_msg_cnt = 0;                           //补发计数

//static uint8_t usb_send_enable = 0;
static uint8_t terminal_mode = TERMINAL_FREE;  //0:无连接，1：网络，2：USB
static uint32_t old_time_stamp;                //旧时间戳  
//static uint32_t alarm_data_stamp;              //报警数据戳
static uint32_t realtime_data_stamp;           //实时数据戳
static uint32_t heart_stamp;                   //心跳戳
//static uint32_t alarm_resend_stamp;            //报警补发戳
static uint8_t send_heart_flag = 0;            //送心跳标记
static uint8_t resend_flash_addr_end_flag = 0;  //查找补发FLASH到结束地址,则置1 , 在接收到心跳时置0, 
//static uint8_t key_state = 0;                  //钥匙状态
//static uint8_t charge_state = 0;               //充电状态

//static uint32_t current_alarm_flag = 0;        //当前报警标志
//static uint8_t current_max_alarm_level = 0;    //当前最大报警级别
//static uint8_t alarm_real_time_send_cnt;
//static uint8_t alarm_resend_cnt;                //报警补发计数
//static uint8_t alarm_resend_over;               //报警补发结束

static uint32_t realtime_data_wr_flash_addr = RESEND_DATA_START_ADDR; //实时数据存储地址, 初始为补发数据开始地址
static uint32_t resend_data_rd_flash_addr = RESEND_DATA_START_ADDR;   //补发数据读FLASH地址, 初始为补发数据开始地址
//static uint32_t alarm_data_wr_flash_addr = ALARM_DATA_START_ADDR;     //报警数据存储地址, 初始为报警数据开始地址
//static uint32_t alarm_data_rd_flash_addr = ALARM_DATA_START_ADDR;     //报警数据读FLASH地址,初始为报警数据开始地址
static uint8_t ckeck_flash_flag = 0;              //检查FLASH标记

uint8_t GB17691_data_package[512];               //GB17691数据包缓存 ,大小512

uint8_t big_heart_flag=0;                            //1:进入大心跳状态, 0:不进入大心跳    网络管理模块会调用 
uint32_t big_heart_time_stamp;                       //大心跳时间戳
static uint32_t big_heart_temp_time_stamp;           //大心跳临时时间戳

static uint8_t TERMINAL_SOFT_VER=0;
uint16_t INFO_STREAM_NO=1;                         //信息流水号


static GB17691_location_t cur_location;

extern u8 net_state;
uint8_t low_power_state;

extern u8 can_state;


//for test logout
uint32_t temp_test_stamp=0;
uint32_t test_logout=0;


uint8_t test_flag=0xff;
uint8_t test_flag_num=0;

//static uint32_t resend_data_stamp;
//	
////#pragma pack(1)   //按字节对齐
//extern GB32960_vehicle_data_t vehicle_data;
//extern GB32960_motor_data_t motor_data;
//	
//#ifdef _FUEL_CELL_DATA_
//extern GB32960_fuel_data_t fuel_cell_data;
//#endif

//#ifdef _ENGINE_DATA_
//extern GB32960_engine_data_t engine_data;
//#endif

//extern GB32960_extreme_t extreme_data;
//extern GB32960_alarm_t alarm_data;
//extern GB32960_charge_device_voltage_t charge_device_voltage_data;
//extern GB32960_charge_device_temp_t charge_device_temp_data;
////#pragma pack()  //取消指定对齐，恢复缺省对齐

/*for save big heart time stamp*/
static void update_big_heart_time(uint32_t time)
{	
		BKP_WriteBackupRegister(BKP_DR2, 0xa5a5);
		BKP_WriteBackupRegister(BKP_DR3, (uint16_t)(time>>16));
		BKP_WriteBackupRegister(BKP_DR4, (uint16_t)(time));	
}

static char IsLeapYear(unsigned int uiYear)
{
	return (((uiYear%4)==0)&&((uiYear%100)!=0))||((uiYear%400)==0);
}

static void set_time_preset(int tzi,rtc_time_t st,rtc_time_t *set_time)
{
	memcpy(set_time,&st,sizeof(rtc_time_t));

	//set_time->hour += tzi;
	
	set_time->second += tzi;
	if(set_time->second >= 60)
	{
		set_time->second -= 60;
		set_time->minute++;
	}
	
	if(set_time->minute >= 60)
	{
		set_time->minute -= 60;
		set_time->hour++;
	}
	
	int iHourInterval= set_time->hour/24;
	set_time->hour %= 24;
	if(iHourInterval>0)
	{
		set_time->date += 1;
		int iDays= 0;
		switch(set_time->month)
		{
			case 1:
			case 3:
			case 5:
			case 7:
			case 8:
			case 10:
			case 12:
			{
				iDays = 31;
			}break;
			case 2:
			{
				iDays = IsLeapYear(st.year)?29:28;
			}break;
			case 4:
			case 6:
			case 9:
			case 11:
			{
				iDays = 30;
			}break;
		}

		int iInterval= set_time->date-iDays;
		if(iInterval>0)
		{
			set_time->date = iInterval;
			set_time->month += 1;
			iInterval = set_time->month/12;
			set_time->month %= 12;
			if(iInterval>0)
			{
				set_time->year += 1;
			}
		}
	}
}


//static void GB17691_send_data(uint8_t* pdata, uint16_t data_len)
//{
//	uint8_t res;
//	//usb_tx_data(pdata, data_len);
////	if(terminal_mode == TERMINAL_USB)
////	{
////		do
////		{
////		  res = usb_tx_data(pdata, data_len);
////		}while(!res);
////	}
////	else
////	{
//	  do
//		{
//			//usb_tx_data(pdata, data_len);
//		  res = sim_uart_tx(pdata, data_len);  //需要判断串口BUF是否满？
//		}while(!res);
////	}
//}

static void GB17691_send_data(uint8_t* pdata, uint16_t data_len)
{
   uint8_t res;
	 do
		{
		  res = sim_uart_tx(pdata, data_len);  //需要判断串口BUF是否满？
		}while(!res);
#ifdef debug
   //USARTSendOut(USART1, "\r\n", 2);		
	 USARTSendOut(USART1, (const char *)pdata, data_len);	 // 
   //USARTSendOut(USART1, "\r\n", 2);
#endif
}

void GB17691_CMD_analysis(uint8_t *pdata, uint16_t len)
{
	switch(pdata[2])
	{
    case VEHICLE_LOGIN_SUCCESS_CMD:
		{
			if(is_set_time())
				{
					rtc_time_t cur_time;
					get_current_time(&cur_time);
					set_lognum(cur_time,lognum);
				}
				send_data_cnt = 0;
				
				resend_flash_addr_end_flag = 0;
				login_state = 1;
		  break;
		}
		case VEHICLE_LOGIN_ERROR_CMD:
		{
		  break;
		}
		
		case VEHICLE_UPLOAD_CMD:
		{
			break;
		}
		
		case VEHICLE_RELOAD_CMD:
		{
			break;
		}
		
		case VEHICLE_LOGOUT_SUCCESS_CMD:
		{
			  login_state = 0;
				timing_state = 0;
				GB17691_send_enable = 0;
				send_data_cnt = 0;
				send_heart_flag = 0;
			  
			  resend_flash_addr_end_flag = 0;
			
			  for(uint8_t i=0; i<realtime_load_cnt;i++)
				{
					write_resend_data_flag(realtime_upload_flag_addr[i], SEND_DATA_FLAG);
				}
				realtime_load_cnt = 0;
				
				for(uint8_t i=0; i<resend_msg_cnt;i++)
				{
					write_resend_data_flag(resend_msg_flag_addr[i], SEND_DATA_FLAG);
				}
				resend_msg_cnt = 0;
			
			break;
		}	
		case VEHICLE_LOGOUT_ERROR_CMD:
		{
			break;
		}

		case VEHICLE_HEART_SUCCESS_CMD:
		{
			  uint32_t new_time_stamp = get_time_stamp();
				if((new_time_stamp - heart_stamp) >= 10)   //10->50 for网络助手调试
				{
					//reset_sim_net();
					GB17691_send_enable = 0;
				}
				else
				{
					send_heart_flag = 0;
					GB17691_send_enable = 1;
				}
				
				resend_flash_addr_end_flag = 0;
				for(uint8_t i=0; i<realtime_load_cnt;i++)   //收到心跳命令,则将已发数据标记为发送成功
				{
					write_resend_data_flag(realtime_upload_flag_addr[i], SEND_DATA_FLAG);
				}
				realtime_load_cnt = 0;
				
				for(uint8_t i=0; i<resend_msg_cnt;i++)     //收到心跳命令,则将补发的数据标记为发送成功
				{
					write_resend_data_flag(resend_msg_flag_addr[i], SEND_DATA_FLAG);
				}
				resend_msg_cnt = 0;
			break;
		}	
		case VEHICLE_HEART_ERROR_CMD:
		{
			break;
		}
		
		case VEHICLE_TIMING_SUCCESS_CMD:
		{
			  uint32_t new_time_stamp = get_time_stamp();
				if((new_time_stamp - old_time_stamp) <= 5)  //5->30 for网络助手调试
				{
					rtc_time_t server_time;
					rtc_time_t set_time;
					server_time.year = pdata[24];
					server_time.month = pdata[25];
					server_time.date = pdata[26];
					server_time.hour = pdata[27];
					server_time.minute = pdata[28];
					server_time.second= pdata[29];
					set_time_preset((new_time_stamp - old_time_stamp + TIME_PRESET_VALUE),server_time,&set_time);  //获得设置时间set_time
					if(set_current_time(set_time) == SUCCESS)
					{
						timing_state = 1;
					}
					send_data_cnt = 0;
					GB17691_send_enable = 1;
								
					if(lognum != get_lognum(server_time))
					{
						set_lognum(set_time,lognum);
					}
				}
			break;
		}
		case VEHICLE_TIMING_ERROR_CMD:
		{
			break;
		}
		
//		case VEHICLE_SET_VIN_CMD:
//		{
//			if(pdata[3] == CMD_PACKAGE)
//			{
//				uint8_t data_temp[67]; //最大67个字节，VIN 17字节，储能编码最大50字节
//				uint8_t esscode_len;
//				uint8_t data;
//				uint8_t res = 0;
//				uint8_t i = 0;
//				esscode_len = (uint16_t)(pdata[22] << 8) + (uint16_t)pdata[23];
//				do{
//					for(i=0;i<17;i++)
//					{
//						data = pdata[i+4];
//						if((data >= 0x30 && data <= 0x39) || (data >= 0x41 &&data <= 0x5a) || (data >= 0x61 && data <= 0x7a))  //必须是数字和字母
//						{
//							data_temp[i] = data;
//						}
//						else
//						{
//							break;
//						}
//					}
//					if(i != 17)
//					{
//						break;
//					}
//					for(i=0;i<esscode_len;i++)
//					{
//						data = pdata[i+24];
//						if((data >= 0x30) && (data <= 0x39)) //必须是数字
//						{
//							data_temp[i+17] = data;
//						}
//						else
//						{
//							break;
//						}
//					}
//					if(i != esscode_len)
//					{
//						break;
//					}
//					if(set_vin_esscode(data_temp, esscode_len+17))
//					{
//						res = 1;
//					}
//					break;
//			  }while(1);
//				
//				if(res)
//				{
//					pdata[3] = ACK_SUCCESS;
//					read_vin_state = 0;
//				}
//        else
//				{
//					pdata[3] = ACK_ERROR;
//				}
//				pdata[len-1] = EvalBCC_FromBytes(&pdata[2], len-3);
//				GB32960_send_data(pdata,len);
//			}
//		}
		default:break;
	}
}

void GB17691_CMD_check(void)
{
//	uint8_t i;
	
	do{
			if(check_cmd_info_flag == 0)
			{
				if(get_sim_rx_data_size(gb17691_rd_pos) > 23)  //至少接收到24个字节，才开始解析
				{
					  get_sim_data_multiple_bytes(GB17691_CMD_data, gb17691_rd_pos, 24);
						if(GB17691_CMD_data[0] == (uint8_t)(START_STRING >> 8))//判断起始符 和 VIN 
						{
							if(GB17691_CMD_data[1] == (uint8_t)(START_STRING))
							{
								
								
//								for(i=0;i<sizeof(vin_info);i++)   //判断VIN
//								{
//									if(vin_info[i] != GB17691_CMD_data[3+i])
//									{
//										break;
//									}
//								}
								
//								if(i==sizeof(vin_info))  //意味起始符合VIN 找到,
//								{
//									cmd_data_len = (uint16_t)(GB17691_CMD_data[22] << 8) + (uint16_t)GB17691_CMD_data[23];
//								
//									cmd_data_len += 25;
// 								//数据单元长度，加上24字节的信息，1个字节的校验，
//								
//									if(cmd_data_len <= sizeof(GB17691_CMD_data))  //判断命令是否超出范围, gb17691_rd_pos++ ,再进入循环
//									{
//										check_cmd_info_flag = 1;
//										CMD_check_dealy = 0;
//									}		
//								}
//20190322 不判断VIN 
									cmd_data_len = (uint16_t)(GB17691_CMD_data[22] << 8) + (uint16_t)GB17691_CMD_data[23];		
									cmd_data_len += 25;
 								//数据单元长度，加上24字节的信息，1个字节的校验，	
									if(cmd_data_len <= sizeof(GB17691_CMD_data))  //判断命令是否超出范围, gb17691_rd_pos++ ,再进入循环
									{
										check_cmd_info_flag = 1;
										CMD_check_dealy = 0;
									}		
						}
					}
					
					if(check_cmd_info_flag == 0)
					{
						gb17691_rd_pos++;
						if(gb17691_rd_pos >= SIM_UART_RX_BUF_SIZE)
						{
							gb17691_rd_pos = 0;
						}
					}
				}
				else
				{
					break;
				}
		}
		else
		{
			if(get_sim_rx_data_size(gb17691_rd_pos) >= cmd_data_len)
			{
				check_cmd_info_flag = 0;
				
				get_sim_data_multiple_bytes(GB17691_CMD_data, gb17691_rd_pos, cmd_data_len);
				if(EvalBCC_FromBytes(&GB17691_CMD_data[2], cmd_data_len-3) == GB17691_CMD_data[cmd_data_len-1])
				{
					gb17691_rd_pos += cmd_data_len;
					if(gb17691_rd_pos >= SIM_UART_RX_BUF_SIZE)
					{
						gb17691_rd_pos -= SIM_UART_RX_BUF_SIZE;
					}
					GB17691_CMD_analysis(GB17691_CMD_data, cmd_data_len);
				}
				else
				{
					gb17691_rd_pos++;
					if(gb17691_rd_pos >= SIM_UART_RX_BUF_SIZE)
					{
						gb17691_rd_pos = 0;
					}
				}
			}
			else
			{
				if(CMD_check_dealy < GB17691_CMD_CHECK_DEALY) //延时1s
				{
					CMD_check_dealy++;
				  break;
				}
				else
				{
					check_cmd_info_flag = 0;
					gb17691_rd_pos++;
					if(gb17691_rd_pos >= SIM_UART_RX_BUF_SIZE)
					{
						gb17691_rd_pos = 0;
					}
				}
			}
		}
	}while(1);
}

uint8_t EvalBCC_FromBytes(uint8_t* Bytes, uint16_t len) 
{
	u32 i;
	u8 bcc = 0;
	for (i = 0; i < len; i++) 
	{
		bcc ^= Bytes[i];
	}
	return bcc;
}

void heart_send(void)   //心跳
{
	rtc_time_t cur_time;
	uint8_t send_data[50];
	
	send_data[0] = (uint8_t)(START_STRING >> 8);
	send_data[1] = (uint8_t)START_STRING;
	send_data[2] = VEHICLE_HEART_CMD;
	
	GB17691_get_VIN_Info(&send_data[3]);
	//send_data[20]= GB17691_get_softver_Info();
	
	//memcpy(&send_data[3],vin_info,sizeof(vin_info));     //VIN
	send_data[20] = TERMINAL_SOFT_VER;                   //软件版本号
	send_data[21] = NO_ENCRYPT;                          //数据加密方式, 不加密
	
	get_current_time(&cur_time);                         //数据采集时间
	send_data[24] = cur_time.year;
	send_data[25] = cur_time.month;
	send_data[26] = cur_time.date;
	send_data[27] = cur_time.hour;
	send_data[28] = cur_time.minute;
	send_data[29] = cur_time.second;
	
	send_data [30]=0x81;                                 //IMEI信息体类型
	send_data [31]=0;
	send_data [32]=0x0f;
	get_imei(&send_data[33]);                            //SIM模块IMEI
	
	send_data[22] = 0;
	send_data[23] = 0x18;                                //6+1+2+15 =24
	
	send_data[48] = EvalBCC_FromBytes(&send_data[2], 46);
	//sim_uart_tx(send_data, 25);
	GB17691_send_data(send_data,49);
	
	old_time_stamp = get_time_stamp();
}

void timing_send(void)  //校时
{
	rtc_time_t cur_time;
	uint8_t send_data[50];
	uint8_t send_data_size;
	
	send_data[0] = (uint8_t)(START_STRING >> 8);         //起始符
	send_data[1] = (uint8_t)START_STRING;          
	send_data[2] = VEHICLE_TIMING_CMD;                   //校时命令
	
	GB17691_get_VIN_Info(&send_data[3]);
	//send_data[20]= GB17691_get_softver_Info();
//	memcpy(&send_data[3],vin_info,sizeof(vin_info));     //VIN
	send_data[20] = TERMINAL_SOFT_VER;                   //软件版本号
	send_data[21] = NO_ENCRYPT;                          //数据加密方式, 不加密
	
	get_current_time(&cur_time);                         //数据采集时间
	send_data[24] = cur_time.year;
	send_data[25] = cur_time.month;
	send_data[26] = cur_time.date;
	send_data[27] = cur_time.hour;
	send_data[28] = cur_time.minute;
	send_data[29] = cur_time.second;
	
	send_data [30]=0x81;                                 //IMEI信息体类型
	send_data [31]=0;
	send_data [32]=0x0f;
	get_imei(&send_data[33]);                            //SIM模块IMEI
	
	send_data[22] = 0;                                   // 6+1+2+15=24
	send_data[23] = 0x18;
	
	send_data_size = 49;                                 //发送数据总个数:22+2+16+1 ;
	send_data[48] = EvalBCC_FromBytes(&send_data[2], 46);
	//sim_uart_tx(send_data, 25);
	GB17691_send_data(send_data,send_data_size);
	
	old_time_stamp = get_time_stamp();
}

void login_send(void)   //登入
{
	rtc_time_t cur_time;
	uint8_t send_data[120];
	uint8_t send_data_size;
	
	send_data[0] = (uint8_t)(START_STRING >> 8);  //起始符
	send_data[1] = (uint8_t)START_STRING;
	send_data[2] = VEHICLE_LOGIN_CMD;             //登录命令
	
	GB17691_get_VIN_Info(&send_data[3]);
	//send_data[20]= GB17691_get_softver_Info();
	//memcpy(&send_data[3],vin_info,sizeof(vin_info));  //VIN
	
	send_data[20] = TERMINAL_SOFT_VER;        //软件版本号
	send_data[21] = NO_ENCRYPT;               //数据加密方式, 不加密
	
	get_current_time(&cur_time);              //数据采集时间
	send_data[24] = cur_time.year;
	send_data[25] = cur_time.month;
	send_data[26] = cur_time.date;
	send_data[27] = cur_time.hour;
	send_data[28] = cur_time.minute;
	send_data[29] = cur_time.second;           
	
//	send_data [30]=0x81;                     //IMEI信息体类型
//	send_data [31]=0;
//	send_data [32]=0x0f;
//	get_imei(&send_data[33]);                //SIM模块IMEI
	
	lognum = get_lognum(cur_time);           //登录流水号
	lognum++;
	send_data[30] = (uint8_t)(lognum >> 8);
	send_data[31] = (uint8_t)lognum;
	
	set_lognum(cur_time, lognum);
	
	get_iccid(&send_data[32]);              //SIM卡ICCID号 
	
		
	send_data[22] = 0;                      //时间6，登入流水号2，ICCID码20，IMEI信息体1  长度 2+ imei 15  共 46字节
	send_data[23] = 0x1c;
		
	send_data_size = 53;                   //发送数据总个数:22+2+46+1 ;
	send_data[send_data_size-1] = EvalBCC_FromBytes(&send_data[2], send_data_size-3);  //校验位
		
		//sim_uart_tx(send_data,send_data_size);
	GB17691_send_data(send_data,send_data_size);   
}

void login_send_new(void)   //登入
{
	rtc_time_t cur_time;
	uint8_t send_data[120];
	uint8_t send_data_size;
	
	send_data[0] = (uint8_t)(START_STRING >> 8);  //起始符
	send_data[1] = (uint8_t)START_STRING;
	send_data[2] = VEHICLE_LOGIN_CMD;             //登录命令
	
	GB17691_get_VIN_Info(&send_data[3]);
	//send_data[20]= GB17691_get_softver_Info();
	//memcpy(&send_data[3],vin_info,sizeof(vin_info));  //VIN
	
	send_data[20] = TERMINAL_SOFT_VER;        //软件版本号
	send_data[21] = NO_ENCRYPT;               //数据加密方式, 不加密
	
	get_current_time(&cur_time);              //数据采集时间
	send_data[24] = cur_time.year;
	send_data[25] = cur_time.month;
	send_data[26] = cur_time.date;
	send_data[27] = cur_time.hour;
	send_data[28] = cur_time.minute;
	send_data[29] = cur_time.second;           
	
//	send_data [30]=0x81;                     //IMEI信息体类型
//	send_data [31]=0;
//	send_data [32]=0x0f;
//	get_imei(&send_data[33]);                //SIM模块IMEI
	
	lognum = get_lognum(cur_time);           //登录流水号
	lognum++;
	send_data[30] = 0;//(uint8_t)(lognum >> 8);
	send_data[31] = 0;//(uint8_t)(lognum);
	send_data[32] = (uint8_t)(lognum >> 8);
	send_data[33] = (uint8_t)lognum;
	
	set_lognum(cur_time, lognum);
	
	get_iccid(&send_data[34]);              //SIM卡ICCID号 
	
		
	send_data[22] = 0;                      //时间6，登入流水号2，ICCID码20，IMEI信息体1  长度 2+ imei 15  共 46字节
	send_data[23] = 0x1e;
		
	send_data_size = 55;                   //发送数据总个数:22+2+46+1 ;
	send_data[send_data_size-1] = EvalBCC_FromBytes(&send_data[2], send_data_size-3);  //校验位
		
		//sim_uart_tx(send_data,send_data_size);
	GB17691_send_data(send_data,send_data_size); 
	
//			#ifdef debug
//			extern void USARTSendOut(USART_TypeDef* USARTx, const char *buf, u16 len);
//			USARTSendOut(RS232_USART, send_data,send_data_size);
//			#endif	
}

void logout_send(void)  //登出
{
	rtc_time_t cur_time;
	uint8_t send_data[60];
	
	send_data[0] = (uint8_t)(START_STRING >> 8);
	send_data[1] = (uint8_t)START_STRING;
	send_data[2] = VEHICLE_LOGOUT_CMD;
	
	GB17691_get_VIN_Info(&send_data[3]);
	//send_data[20]= GB17691_get_softver_Info();
	
	//memcpy(&send_data[3],vin_info,sizeof(vin_info));
	
	send_data[20] = TERMINAL_SOFT_VER;        //软件版本号
	send_data[21] = NO_ENCRYPT;               //数据加密方式, 不加密
	
	get_current_time(&cur_time);
	send_data[24] = cur_time.year;
	send_data[25] = cur_time.month;
	send_data[26] = cur_time.date;
	send_data[27] = cur_time.hour;
	send_data[28] = cur_time.minute;
	send_data[29] = cur_time.second;
	
	send_data [30]=0x81;                     //IMEI信息体类型
	send_data [31]=0;
	send_data [32]=0x0f;
	get_imei(&send_data[33]);                            //SIM模块IMEI
	
	send_data[48] = (uint8_t)(lognum >> 8);  //登出流水号
	send_data[49] = (uint8_t)lognum;
		                                       
	send_data[22] = 0x00;                    //登出报文数据单元，时间，登出流水号 IMEI     6+2+1+2+15 =26字节
	send_data[23] = 0x1a; 
	
	send_data[50] = EvalBCC_FromBytes(&send_data[2], 48);
	
	//sim_uart_tx(send_data,33);
	GB17691_send_data(send_data,51);
}


void GB17691_data_put_buf(uint8_t handle)   //打包 存储  上报
{
	uint16_t data_len = 0;
//	uint16_t temp_len=0;
//	uint8_t temp_buf[36]={0};
	save_resend_data_t save_data_status;
	
	// if(is_set_time())
	{
		GB17691_data_package[0] = (uint8_t)(START_STRING >> 8);                             // 起始符 0x2323
		GB17691_data_package[1] = (uint8_t)(START_STRING);
	
		//memcpy(&GB17691_data_package[3],vin_info,sizeof(vin_info));                         //VIN
		GB17691_get_VIN_Info(&GB17691_data_package[3]);
		
		//GB17691_data_package[20]= GB17691_get_softver_Info();
		

	  GB17691_data_package[20] = TERMINAL_SOFT_VER;                                    //软件版本号
	//	GB17691_data_package[20] =temp_soft_ver;                                           //软件版本号
		GB17691_data_package[21] = NO_ENCRYPT;                                             //数据加密方式 0x01
	
		rtc_time_t cur_time;
		get_current_time(&cur_time);                                                        // 获取RTC 当前时间
		save_data_status.timestamp = get_time_stamp();                                      // 时间计数
		
		memcpy(&GB17691_data_package[24+data_len],&cur_time,sizeof(rtc_time_t));            //加上当前时间
		data_len += sizeof(rtc_time_t);
		
		GB17691_data_package[24+data_len]= (uint8_t)(INFO_STREAM_NO>>8);                    //信息流水号
		GB17691_data_package[25+data_len]= (uint8_t)(INFO_STREAM_NO);
		data_len +=2;
		
//		GB17691_data_package[24+data_len] = GB17691_INFO_IMEI_DATA;                      // 信息类型标志:IMEI信息体  ,0X81
//		data_len += 1;
//		GB17691_data_package[24+data_len]=0;                                            //IMEI长度 2字节表示 
//		GB17691_data_package[25+data_len]=0x0f;
//		data_len +=2;
//		get_imei(&GB17691_data_package[24+data_len]);                          
//		data_len +=15;
		
		GB17691_data_package[24+data_len] = GB17691_INFO_OBD_DATA;                         // 信息类型标志:OBD信息 ,0X01
		data_len += 1;

    data_len += GB17691_get_OBD_Info(&GB17691_data_package[24+data_len]);           //OBD信息
		
		GB17691_data_package[24+data_len] = GB17691_INFO_DATASTREAM_DATA;                               //信息类型标志:数据流信息 ,0X02
		data_len += 1;
		
		data_len += GB17691_get_datastream_Info(&GB17691_data_package[24+data_len]);                                                  //获取数据流信息

		GB17691_data_package[24+data_len] = GB17691_INFO_CUSTOM_DATA;                         // 信息类型标志:自定义信息  ,0X80
		data_len += 1;
		data_len += GB17691_get_custom_Info(&GB17691_data_package[24+data_len]);                                                //获取自定义信息体
			
		GB17691_data_package[22] = (uint8_t)(data_len >> 8);                   // 6+ 2 + 1+2+15 + 1+96 +1+37 +1+2+8
		GB17691_data_package[23] = (uint8_t)data_len;
			
			if(handle & REAL_TIME_UPLOAD)                                                         //实时上报
			{
				GB17691_data_package[2] = VEHICLE_UPLOAD_CMD;//VEHICLE_UPLOAD_CMD;
				GB17691_data_package[24+data_len] = EvalBCC_FromBytes(&GB17691_data_package[2], data_len+22);//异或校验字
				GB17691_send_data(GB17691_data_package, 24+data_len+1);                           //实时上报
				INFO_STREAM_NO++;                                                                 //需优化:中间设备断电,则需做存储处理, 以天为单位,从1开始累加  
				if(INFO_STREAM_NO>=65531){
					INFO_STREAM_NO=0;
				}
			
//			#ifdef debug
//			extern void USARTSendOut(USART_TypeDef* USARTx, const char *buf, u16 len);
//			USARTSendOut(USART1, GB17691_data_package,data_len);
//			#endif
				
				
			}

			
			
			GB17691_data_package[2] = VEHICLE_RELOAD_CMD;
			GB17691_data_package[24+data_len] = EvalBCC_FromBytes(&GB17691_data_package[2], data_len+22);  //异或校验字
			data_len += 1;
		
			if(handle & SAVE_RESEND_DATA)    //存储数据
			{
				if((handle & REAL_TIME_UPLOAD) && (terminal_mode == TERMINAL_NET))
				{
					save_data_status.resend_flag = REALTIME_UPLOAD_FLAG;
					realtime_upload_flag_addr[realtime_load_cnt] = realtime_data_wr_flash_addr + 24 + data_len + (sizeof(save_resend_data_t) - 2); //最后两个字节是标志位
					if(realtime_upload_flag_addr[realtime_load_cnt] >= RESEND_DATA_END_ADDR)
					{
						realtime_upload_flag_addr[realtime_load_cnt] -= RESEND_DATA_END_ADDR;
						realtime_upload_flag_addr[realtime_load_cnt] += RESEND_DATA_START_ADDR;
					}
					realtime_load_cnt++;
					if(realtime_load_cnt >= (sizeof(realtime_upload_flag_addr) / sizeof(uint32_t))) //防止溢出
					{
						realtime_load_cnt = 0;
					}
				}
				else
				{
					save_data_status.resend_flag = RESEND_DATA_FLAG;
				}
							
				memcpy(&GB17691_data_package[24+data_len],&save_data_status,sizeof(save_resend_data_t));   // 实时上报数据 + 时间戳+ 包计数+ 包数量+ 包状态标记 
			  write_data_to_flash(GB17691_data_package,realtime_data_wr_flash_addr,24+data_len+sizeof(save_resend_data_t),RESEND_DATA_FLASH_AREA);    // 数据写入FLASH
				
				realtime_data_wr_flash_addr += (24+data_len+sizeof(save_resend_data_t));
				if(realtime_data_wr_flash_addr >= RESEND_DATA_END_ADDR)
				{
					realtime_data_wr_flash_addr -= RESEND_DATA_END_ADDR;
					realtime_data_wr_flash_addr += RESEND_DATA_START_ADDR;
				}
				
				/***存储每超过2M记录一下实时数据读写FLASH地址 ****************************/
//				resend_wrtie_size += (24+data_len+sizeof(save_resend_data_t));
//				if(resend_wrtie_size >= RESEND_WRITE_MAX_SIZE) //2M
//				{
//					//save_resend_record_addr(&resend_record_addr, realtime_data_wr_flash_addr);  //在用车OBD项目不存储补发数据地址
//					resend_wrtie_size = 0;
//				}		
			}
			
	}
}

static uint8_t get_terminal_connect_status(void)
{
	uint8_t mode;
//	if(is_usb_connected())
//	{
//		mode = TERMINAL_USB;
//	}
//	else
	{
		//	if(get_net_status() == 0x01)
    if(get_net_status() == ON_LINE)
		{
			mode = TERMINAL_NET;//  网络连接模式
		}
		else
		{
			mode = TERMINAL_FREE;//自由模式,
		}
	}
	return mode;
}

//void GB17691_real_time_upload(void)
//{
//	uint32_t new_time_stamp;
//	uint8_t GB17691_data_handle = 0;
//  uint8_t current_mode;
//	
//	new_time_stamp = get_time_stamp();
//	
//	
//	current_mode = get_terminal_connect_status();
//	if(terminal_mode != current_mode)     // 模式有改变, 如果是网络连接状态变为其他状态,则 将实时上报数据改为需要补发上报的数据
//	{
//		if(terminal_mode==TERMINAL_NET)
//		{
//			for(uint8_t i=0; i<realtime_load_cnt;i++)
//			{
//				write_resend_data_flag(realtime_upload_flag_addr[i], RESEND_DATA_FLAG);  
//			}
//		}
//		terminal_mode = current_mode;
//		login_state = 0;
//		timing_state = 0;
//		GB17691_send_enable = 0;
//		send_data_cnt = 0;
//		send_heart_flag = 0;
//		realtime_load_cnt = 0;
//		resend_msg_cnt = 0;
//	}
//	
//	if(can_state==1)
//	{
//    if(terminal_mode == TERMINAL_NET)	
//		{
//			if(login_state == 0)
//			{
//				login_send_new();
//				send_data_cnt++;
//				login_state = 1;
//				timing_state = 1;
//				resend_flash_addr_end_flag = 0;
//				realtime_load_cnt = 0;
//				resend_msg_cnt = 0;
//				GB17691_send_enable = 1;
//				old_time_stamp = new_time_stamp;
//			}
//			else
//			{
//				if((new_time_stamp - heart_stamp) >= HEART_INTERVAL)  //心跳间隔50S 改为180S  for 网络助手调试
//				{
//					resend_msg_cnt=0;
//					heart_stamp = new_time_stamp;
//					
//					resend_flash_addr_end_flag = 0;
//					for(uint8_t i=0; i<realtime_load_cnt;i++)   //收到心跳命令,则将已发数据标记为发送成功
//					{
//						write_resend_data_flag(realtime_upload_flag_addr[i], SEND_DATA_FLAG);
//					}
//					realtime_load_cnt = 0;
//					
//					for(uint8_t i=0; i<resend_msg_cnt;i++)     //收到心跳命令,则将补发的数据标记为发送成功
//					{
//						write_resend_data_flag(resend_msg_flag_addr[i], SEND_DATA_FLAG);
//					}
//					resend_msg_cnt = 0;
//				}
//			}
//		}
//	
//		if((new_time_stamp - realtime_data_stamp) >= MSG_SEND_INTERVAL)
//		{
//			realtime_data_stamp = new_time_stamp;
//			GB17691_data_handle |= SAVE_RESEND_DATA;
//			if(GB17691_send_enable)
//			{
//				GB17691_data_handle |= REAL_TIME_UPLOAD;
//			}

//			if(GB17691_data_handle)
//			{
//				GB17691_data_put_buf(GB17691_data_handle);//打包 存储 上报 
//			} 
//		}	
//	}
//	else
//	{
//		if(((terminal_mode == TERMINAL_NET)) && login_state)
//		{
//			logout_send();
//			login_state = 0;	//------------------上海移动 登出后状态置0
//	  }
//		else
//		{
//			login_state = 0;
//			realtime_load_cnt = 0;
//		  resend_msg_cnt = 0;
//		}
//	}
//}


void GB17691_real_time_upload(void)
{
	uint32_t new_time_stamp;
	uint8_t GB17691_data_handle = 0;
  uint8_t current_mode;
	
	new_time_stamp = get_time_stamp();
	
	current_mode = get_terminal_connect_status();
	if(terminal_mode != current_mode)     // 模式有改变, 如果是网络连接状态变为其他状态,则 将实时上报数据改为需要补发上报的数据
	{
		if(terminal_mode==TERMINAL_NET)
		{
			for(uint8_t i=0; i<realtime_load_cnt;i++)
			{
				write_resend_data_flag(realtime_upload_flag_addr[i], RESEND_DATA_FLAG);  
			}
		}
		terminal_mode = current_mode;
		login_state = 0;
		timing_state = 0;
		GB17691_send_enable = 0;
//		send_data_cnt = 0;
		send_heart_flag = 0;
		realtime_load_cnt = 0;
		resend_msg_cnt = 0;
	}
	
	if((big_heart_flag==1) || (can_state==1))
	{
    if(terminal_mode == TERMINAL_NET)	
		{
			if(login_state == 0)
			{
				login_send_new();
				login_state = 1;
				resend_flash_addr_end_flag = 0;
				realtime_load_cnt = 0;
				resend_msg_cnt = 0;
				GB17691_send_enable = 1;
				heart_stamp = new_time_stamp;
			}
			else
			{
				if((new_time_stamp - heart_stamp) >= HEART_INTERVAL)
				{
					heart_stamp = new_time_stamp;
					resend_flash_addr_end_flag = 0;
					
					for(uint8_t i=0; i<realtime_load_cnt;i++)   //将已发数据标记为发送成功
					{
						write_resend_data_flag(realtime_upload_flag_addr[i], SEND_DATA_FLAG);
					}
					realtime_load_cnt = 0;
					
					for(uint8_t i=0; i<resend_msg_cnt;i++)     //则将补发的数据标记为发送成功
					{
						write_resend_data_flag(resend_msg_flag_addr[i], SEND_DATA_FLAG);
					}
					resend_msg_cnt = 0;
				}
				
				if((timing_state==0)&&(send_data_cnt==0))
				{
					timing_send();
					send_data_cnt++;
				}
			}
		}
		else
		{
			if(big_heart_flag==1)
			{
			    if((new_time_stamp - big_heart_temp_time_stamp) >= 300) //发大心跳成功是否超时5分钟,此次心跳不发了,跳出,否则重新发  
					{
						big_heart_flag=0;
#ifdef debug						
					  USARTSendOut(USART1, "send big heart over time!\r\n", 27);
#endif						
						big_heart_time_stamp=new_time_stamp;
						update_big_heart_time(big_heart_time_stamp);
					}
			}
		}	
		
		if(big_heart_flag==1)
		{	  
			    if(login_state == 1)
					{
					  get_GB17691_gps_info(&cur_location);
						if(cur_location.status.is_valid==0)              // 0 : 表示有效 1表示无效
						{  
							   //GB17691_data_handle |= SAVE_RESEND_DATA;     // 按实时上报数据格式处理,传一下GPS信息, 但不存储
					      if(GB17691_send_enable)
				        {
						      GB17691_data_handle |= REAL_TIME_UPLOAD;
					      }
							
							  if(GB17691_data_handle)
							  {
							  	GB17691_data_put_buf(GB17691_data_handle);
							  }                                
							  big_heart_flag=0;
							  big_heart_time_stamp=new_time_stamp;
							  update_big_heart_time(big_heart_time_stamp); 
				    }else if((new_time_stamp - big_heart_temp_time_stamp) >= 300){   //20190312 add  for test 300->180
							  if(GB17691_send_enable)
				        {
						      GB17691_data_handle |= REAL_TIME_UPLOAD;
					      }
								if(GB17691_data_handle)
								{
									GB17691_data_put_buf(GB17691_data_handle);
								}                                
								big_heart_flag=0;
								big_heart_time_stamp=new_time_stamp;
								update_big_heart_time(big_heart_time_stamp); 
						}
						
					}
					else
					{
						if((new_time_stamp - big_heart_temp_time_stamp) >= 300) 
						 {
									big_heart_flag=0;
#ifdef debug						
					        USARTSendOut(USART1, "send big heart over time1!\r\n", 28);
#endif
									big_heart_time_stamp=new_time_stamp;
								  update_big_heart_time(big_heart_time_stamp); 
							}
					}
			}
			else
			{
				if((new_time_stamp - realtime_data_stamp) >= MSG_SEND_INTERVAL)
				{
				 if(can_state==1) //防止大心跳标志为0时,对数据进行存储
					 {
							realtime_data_stamp = new_time_stamp;
							GB17691_data_handle |= SAVE_RESEND_DATA;
							if(GB17691_send_enable)
							{
								GB17691_data_handle |= REAL_TIME_UPLOAD;
							}
				
							if(GB17691_data_handle)
							{
								GB17691_data_put_buf(GB17691_data_handle);//打包 存储 上报 
							  big_heart_time_stamp=new_time_stamp;      //更新大心跳时间戳
								update_big_heart_time(big_heart_time_stamp);
							} 
			     }
			   }
		  }	
	}
	else
	{
		if(((terminal_mode == TERMINAL_NET)) && login_state)
		{
				logout_send();
				login_state = 0;
				GB17691_send_enable = 0;
			
				for(uint8_t i=0; i<realtime_load_cnt;i++)   //将已发数据标记为发送成功
				{
					write_resend_data_flag(realtime_upload_flag_addr[i], SEND_DATA_FLAG);
				}
				realtime_load_cnt = 0;
				
				for(uint8_t i=0; i<resend_msg_cnt;i++)     //将补发的数据标记为发送成功
				{
					write_resend_data_flag(resend_msg_flag_addr[i], SEND_DATA_FLAG);
				}
				resend_msg_cnt = 0;
	  }
		else
		{
			login_state = 0;
			GB17691_send_enable = 0;
//			send_data_cnt = 0;
			realtime_load_cnt = 0;
		  resend_msg_cnt = 0;
			
			if(BKP_ReadBackupRegister(BKP_DR5) == 0x5a5a){    //第一次上电 大心跳
					big_heart_flag=1;
			  	big_heart_temp_time_stamp = new_time_stamp;
				  BKP_WriteBackupRegister(BKP_DR5, 0xa5a5);			
			}
		
			if(BKP_ReadBackupRegister(BKP_DR2) == 0xa5a5){
			if((new_time_stamp - big_heart_time_stamp)>86400)  //时间间隔24小时
			//	if((new_time_stamp - big_heart_time_stamp)>600)  //时间间隔10分钟
				{
					big_heart_flag=1;
					big_heart_temp_time_stamp = new_time_stamp;
				}
			}
		}
	}
}







/*
功能:根据起始符 VIN  校验码, 找数据位置, 补发数据信息地址, 以及补发开始地址更新
参数: uint32_t* addr 补发开始地址  函数中会更新
      uint32_t* resend_info_addr  补发数据信息地址  函数中会更新
返回: 数据地址

*/
uint8_t* read_msg_from_flash(uint32_t* addr, uint32_t* resend_info_addr,uint8_t flash_area)
{
	uint16_t data_len = 0;
	uint16_t i = 0;
	uint32_t res_addr = *addr;
	uint8_t* data_pos = NULL;

	read_data_from_flash(GB17691_data_package,*addr,sizeof(GB17691_data_package),flash_area); //从addr读数据放GB17691_data_package
	for(i = 0; i < sizeof(GB17691_data_package); i++)
	{
		if(GB17691_data_package[i] == 0x23)   
		{
			if((i + 23) < sizeof(GB17691_data_package))
			{
				if(GB17691_data_package[i+1] == 0x23)
				{
//					for(j = 0; j < sizeof(vin_info); j++)
//					{
//						if(GB17691_data_package[i+3+j] != vin_info[j])
//						{
//							break;
//						}
//					}
//					if(j == sizeof(vin_info))
//					{
//						data_len = (GB17691_data_package[i+22] << 8) + GB17691_data_package[i+23];
//						if((i+23+data_len+1+sizeof(save_resend_data_t)) < sizeof(GB17691_data_package))
//						{
//							uint8_t BCC_check = EvalBCC_FromBytes(&GB17691_data_package[i+2], data_len+22);
//							if(BCC_check == GB17691_data_package[i+23+data_len+1])
//							{
//								data_pos = &GB17691_data_package[i];
//								*resend_info_addr = res_addr + i + 24 + data_len + 1;
//								i += (24+data_len+1+sizeof(save_resend_data_t));
//								break;
//							}
//						}
//						else
//						{
//							//i++;
//							break;
//						}
//					}
					  data_len = (GB17691_data_package[i+22] << 8) + GB17691_data_package[i+23];
						if((i+23+data_len+1+sizeof(save_resend_data_t)) < sizeof(GB17691_data_package))
						{
							uint8_t BCC_check = EvalBCC_FromBytes(&GB17691_data_package[i+2], data_len+22);
							if(BCC_check == GB17691_data_package[i+23+data_len+1])
							{
								data_pos = &GB17691_data_package[i];
								*resend_info_addr = res_addr + i + 24 + data_len + 1;
								i += (24+data_len+1+sizeof(save_resend_data_t));
								break;
							}
						}
				}
			}
			else
			{
				//i++;
				break;
			}
		}
	}
	*addr = res_addr + i;
	return data_pos;
}

void GB17691_resend_data(void)
{
	uint16_t data_len;
	uint8_t send_flag = 0;
	uint32_t resend_flag_addr;

	save_resend_data_t *save_data_satus;
	
	uint8_t *msg_pos = NULL;
	
//	uint32_t test_addr;
	
	if(login_state)
	{

			if((GB17691_send_enable) && (resend_msg_cnt < RESND_MSG_MAX_CNT) && (!resend_flash_addr_end_flag))
			{
			
	//			test_addr = resend_data_rd_flash_addr;
				
				msg_pos = read_msg_from_flash(&resend_data_rd_flash_addr,&resend_flag_addr,RESEND_DATA_FLASH_AREA);
				if(resend_data_rd_flash_addr >= RESEND_DATA_END_ADDR)
				{
					resend_flash_addr_end_flag = 1;
					
					resend_data_rd_flash_addr -= RESEND_DATA_END_ADDR;
					resend_data_rd_flash_addr += RESEND_DATA_START_ADDR;
				}
		  }

		if(msg_pos != NULL)
		{
			data_len = (msg_pos[22] << 8) + msg_pos[23];
			save_data_satus = (save_resend_data_t*)&msg_pos[25+data_len];

				if(save_data_satus->resend_flag == RESEND_DATA_FLAG)
				{
          send_flag = 1;
				}
        else
				{
					if(save_data_satus->resend_flag == REALTIME_UPLOAD_FLAG)
					{
						uint32_t cur_stamp =  get_time_stamp();
					//	if((cur_stamp - save_data_satus->timestamp) > (HEART_INTERVAL >> 2))
						if((cur_stamp - save_data_satus->timestamp) > (HEART_INTERVAL << 1))   //补发100秒前数据
						{
							send_flag = 1;
						}
					}
				}					
				
//				uint8_t test_data[100];
//				int res = snprintf((char*)test_data,100,"this is RESEND data READ addr  %08X, %02X,%02X,%02X,%02X,%02X,%02X\n", \
//				test_addr, \
//				msg_pos[24], \
//				msg_pos[25], \
//				msg_pos[26], \
//				msg_pos[27], \
//				msg_pos[28], \
//				msg_pos[29]);
//				usb_tx_data(test_data, strlen((char*)test_data));
				
	
			if(send_flag)
			{
				GB17691_send_data(msg_pos,25+data_len);       //  22+2 +data_len +1 
				
				if(terminal_mode == TERMINAL_NET)
				{
					if(resend_flag_addr >= RESEND_DATA_END_ADDR)
					{
						resend_flag_addr -= RESEND_DATA_END_ADDR;
						resend_flag_addr += RESEND_DATA_START_ADDR;
					}
					
					//重发标志偏移6个字节 ,即下一包数据补发开始地址
					resend_flag_addr += 6;
					if(resend_flag_addr >= RESEND_DATA_END_ADDR)
					{
						resend_flag_addr -= RESEND_DATA_END_ADDR;
						resend_flag_addr += RESEND_DATA_START_ADDR;
					}
					
					resend_msg_flag_addr[resend_msg_cnt] = resend_flag_addr;
					resend_msg_cnt++;
					if(resend_msg_cnt > RESND_MSG_MAX_CNT)
					{
						resend_msg_cnt = 0;
					}
			  }
		  }
		}
	}
}

///**********************************************************
//        获得补发开始写地址
//***********************************************************/
void check_flash(void)   
{
  uint32_t addr;
	uint32_t addr_temp;
	uint8_t *msg_pos;
	uint32_t resend_flag_addr;
	uint32_t max_time_stamp = 0;	
//	rtc_time_t time;
	
  addr = RESEND_DATA_START_ADDR ;

/*******************************************************
从存储的补发数据里找出时间戳最大的那包数据地址, 以及实时数据读写地址  
******************************************************/	
	uint32_t check_flash_size  = RESEND_DATA_START_ADDR; 
	
	while(check_flash_size < RESEND_DATA_END_ADDR)
	{
		addr_temp = addr;
		msg_pos = read_msg_from_flash(&addr,&resend_flag_addr,RESEND_DATA_FLASH_AREA); // 从FLASH里找 数据位置, 补发开始地址, 补发数据信息地址,
		
		check_flash_size += (addr - addr_temp);
		
		if(addr>=RESEND_DATA_END_ADDR)
		{
			addr -= RESEND_DATA_END_ADDR;
			addr += RESEND_DATA_START_ADDR;
		}
		if(msg_pos != NULL)
		{
			uint16_t data_len = (msg_pos[22] << 8) + msg_pos[23];
			uint32_t timestamp = (msg_pos[28+data_len] << 24) + (msg_pos[27+data_len] << 16) +(msg_pos[26+data_len] << 8) +(msg_pos[25+data_len]);	
			if(timestamp >= max_time_stamp)
			{
				max_time_stamp = timestamp;
				realtime_data_wr_flash_addr = addr;
			}
		}
	}

/***************************************************************************
	判断上面得到的实时数据读写FLASH地址之后的FLSAH是否可以写, 
	若不可以写,则跳到下一个secter, 若可以写则接着写.
	注意:	FLASH写之前会擦除,是FF才可以写, 写一个新的secter时会先擦除该扇区再写!	
	***************************************************************************/
	
  uint16_t secoff = realtime_data_wr_flash_addr % FLASH_SECTOR_SIZE;
	uint16_t remain = FLASH_SECTOR_SIZE - secoff;
	uint16_t read_size = 0;
	uint16_t i;
	if(secoff > 0)
	{
		do
		{
			if(remain <= sizeof(GB17691_data_package))
			{
				read_size = remain;
			}
			else
			{
				read_size = sizeof(GB17691_data_package);
			}
			read_data_from_flash(GB17691_data_package,realtime_data_wr_flash_addr,read_size,RESEND_DATA_FLASH_AREA);
			for(i=0; i<read_size;i++)
			{
				if(GB17691_data_package[i] != 0xFF)
				{
					realtime_data_wr_flash_addr = ((realtime_data_wr_flash_addr / FLASH_SECTOR_SIZE) + 1)*FLASH_SECTOR_SIZE;  //如果非空，开始从下一个secter开始。
					break;
				}
			}
			if(i==read_size)
			{
			  remain -= read_size;
			}
			else
			{
				break;
			}
	  }while(remain > 0);
	}
		
	ckeck_flash_flag = 1;
}

uint8_t gps_set_time(void)
{
	rtc_time_t cur_time;
	if(!is_set_time())
	{
		if(get_gps_time(&cur_time))
		{
			set_current_time(cur_time);
			if(BKP_ReadBackupRegister(BKP_DR6) == 0x5a5a){
			      BKP_WriteBackupRegister(BKP_DR6, 0xa5a5);  //第一次校时成功
			}else{
			      BKP_WriteBackupRegister(BKP_DR6, 0x5a5a);  //第一次校时成功
			}
			return 1;
		}
		return 0;
	}
	return 0;
}


uint8_t get_login_state(void)
{
	return login_state;
}

uint8_t get_big_heart_flag(void)
{
	return big_heart_flag;
}

extern u8 flag_set_vin;

void GB17691_task(void const *pvParameters)
//void GB17691_task(void)
{
	u8 vin_state=0;
	u8 cnt_getvin=0;

	
	vin_state=get_vin(vin_info);
  while(1)
  {
		if(!vin_state)
		{
			if(cnt_getvin<10)
			{
					cnt_getvin++;
					if(get_vin(vin_info))
					{
						vin_state = 1;
					}
			}	
		}
		
		
		if(flag_set_vin)
		{
			set_vin(vin_info);
			flag_set_vin=0;
		}
		
		
		
		
	//	if(ckeck_flash_flag)
		
		if((ckeck_flash_flag &&(can_state==1)) || (can_state==0) || (can_state==0xff))
		{
		//	CAN_analysis_data();
			gps_process_frame();	
			//gps_set_time();
			if(gps_set_time() && (BKP_ReadBackupRegister(BKP_DR6) == 0x5a5a)){  //第一次GPS校时成功
					big_heart_temp_time_stamp=get_time_stamp();        
					update_big_heart_time(get_time_stamp());
			}
			//if(is_set_time())
		//	{
			  GB17691_real_time_upload();
	//		}
// 			GB17691_resend_data();
			GB17691_CMD_check();
			osDelay(GB17691_THREAD_DEALY);
		}
		else
		{
			check_flash();
			osDelay(100);
		}
	}
}

void GB17691_init(void)
{

	//check_flash();
}

osThreadId tid_GB17691_task;
osThreadDef (GB17691_task, osPriorityNormal, 1, 1000);
void GB17691_task_init(void)
{
	TERMINAL_SOFT_VER=GB17691_get_softver_Info();   // 获取设备类型 软件版本号	
	if(BKP_ReadBackupRegister(BKP_DR2) == 0xa5a5)
	{
		big_heart_time_stamp= ((uint32_t)BKP_ReadBackupRegister(BKP_DR3) <<16 )|((uint32_t)BKP_ReadBackupRegister(BKP_DR4));
		test_flag=0x00;
	}else{
		big_heart_time_stamp=get_time_stamp();        //第一次上电
	  update_big_heart_time(get_time_stamp());
		BKP_WriteBackupRegister(BKP_DR5, 0x5a5a);
		test_flag=0x01;
	}
	tid_GB17691_task = osThreadCreate (osThread(GB17691_task), NULL);
}









